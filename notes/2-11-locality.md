# 2.11 Locality

## Textbook

* 6.2
* 6.3
* 6.4

## Outline

* 局部性
* 内存的等级制度
* 缓存

## Locality

何谓局部性？

和人类一样，计算机程序也倾向于使用最近使用过的「指令」（「内存」）附近的「指令」（「内存」）。

这种程序的性质被称为「局部性」。

### Definition

#### Categories

##### Temporal Locality

时间局部性。

最近刚刚访问过的项目有较高可能在将来被再度访问。

![image-20200804165546455](2-11-locality.assets/image-20200804165546455.png)

##### Spatial Locality

空间局部性。

彼此相邻的项目有较高概率相继被访问。

![image-20200804165552894](2-11-locality.assets/image-20200804165552894.png)

> 通常来说，程序同时具有这两种局部性。

### Compilers' Perspective



### Example

#### `sumvec`

```c
#define N 8

int sumvec(int v[N])
{
    int i, sum = 0;
    for (i = 0; i < N; i++)
        sum += v[i];
    return sum;
}
```

可以简单地观察出程序的访存路径：

![image-20200804170240356](2-11-locality.assets/image-20200804170240356.png)

其中，变量 `i`、`sum` 满足时间局部性；而对数组 `v` 则满足空间局部性，且访存步长为 `1`。

> 我们定义 `k` 访存步长为：对一段连续的内存，从每 `k` 个字节中访问其中一个。
>
> `k` 越小，空间局部性越明显；反之越不明显。

#### `sumarrayrows`

考虑另一个函数，它对一个矩阵中的全部元素求和，而且采用的是「先行後列」的方式。

```c
#include "config.h"

int sumarrayrows(int a[M][N])
{
    int i, j, sum = 0;

    for (i = 0; i < M; i++)
        for (j = 0; j < N; j++)
            sum += a[i][j];
    return sum;
}
```

由于我们的多维数组在内存中就是以「先行後列」的方式存储的，因此在 `M = 2`、`N = 3` 时，可以看到 `a` 的寻址规律如下：

![image-20200805164256078](2-11-locality.assets/image-20200805164256078.png)

具有规律的 1 步长。

但如果我们换个方式，按照列先求和：

```c
#include "config.h"

int sumarraycols(int a[M][N])
{
    int i, j, sum = 0;

    for (j = 0; j < N; j++)
        for (i = 0; i < M; i++)
            sum += a[i][j];
    return sum;
}
```

![image-20200805164726464](2-11-locality.assets/image-20200805164726464.png)

可以看到就没有这么良好的局部性了：步长变大且不规律，导致缓存困难、效率下降。

在 `M`、`N` 变得非常大的时候，这种情况会更糟糕。

#### Latent Locality

事实上，上面的两个例子里还有一个很不明显的局部性，那就是指令的「时间局部性」。

可以看到，`sum += a[i][j]` 这行语句对应的指令在循环中被反复读取执行，这使其有较高概率被放在 `i-cache` 之中。这也是一种局部性。

## Memory Hierarchy

内存的等级结构…是森严的。

### the Major Gap

CPU 和内存之间有着巨大的鸿沟。以寄存器为代表的 SRAM 和以主存为代表的 DRAM 之间的读速、储存空间差异过大，且交流信息相当慢。

早期计算机没有缓存，这就意味着访问一条目数据要么非常快（如果被放在了 CPU 内部的寄存器中），要么非常慢（如果是从内存中取出来的）。这就要求程序极其高效地应用有限的寄存器，也就是保证局部性。

### Cache it!

#### Pyramid

![image-20200805170937285](2-11-locality.assets/image-20200805170937285.png)

这个金字塔结构非常完美：（通常来说）越靠顶部的缓存级，储存空间越小、读取速度越快；反之越靠底部的缓存级，储存空间越大、读取速度越慢。

#### Cache Idea

内存架构的基本思想是：对每一个缓存级 $k$ 都作为比它更慢一级的缓存级 $k + 1$ 的缓存存在，保存下一级中常用的数据。

CPU 缓存时，从 `L0` 开始依次往下找，直到找到一层保存了这个值的缓存，则返回给 CPU。否则，一直往下找，直到最底层。

> 在实际的单机计算机中，一般存在着 `L0` ～ `L5` 这六层缓存级别。
>
> 存在 `L5` 的原因是在虚拟内存大小超过物理内存大小时，可能会有一部分页被放在磁盘中。

#### Cache Concepts

![image-20200805172133056](2-11-locality.assets/image-20200805172133056.png)

上面也提到了，缓存的要义就是，始终把常用的数据放在访问快的缓存级中，而把不常用的数据放到访问慢的缓存级中。

有几个概念我们需要了解：

##### Hit

在 CPU 自上而下地访问内存级、想要读取一个值时，「在某一个内存级找到了想要的数据」的事件被称为一次「Hit」。

![image-20200805172442769](2-11-locality.assets/image-20200805172442769.png)

> Hit!

Hit 当然是好的；就不需要再继续往下找了。这代表我们的缓存多少发挥了点作用。

当然，无论如何到最底层的缓存级（它都不能叫缓存级了，因为他不作为任何层级的缓存）都是能 Hit 上的。

##### Miss

和 Hit 相对，有 Hit 就有 Miss。「当读寻址下降到某一层级，却发现该层级没有所需的值」，这种情形就叫做 Miss。

遇到 Miss 之后就得接着往下一层级找。

###### Cold Miss

在这一层级的 Cache 有空位，但却没有 Hit 到的时候，我们可以断定这是因为这个数据之前从没被访问过，所以没有进入 Cache。

称这种情况为 Cold Miss，即在刚开机、所有 Cache 都是空的时候会出现的情况。

###### Capacity Miss

假如这一层级的 Cache 里曾经出现过这个数据，但却在稍後访问时 Cache Miss 了，这就说明由于 Cache 的容量不足导致其被驱逐（Evict）出去了。

这种 Miss 称为 Capacity Miss，即 Cache 容量不足时会出现的情况。

